只允许操作符“+”、“*”、“(”、“)”。“(”进栈前优先级最高，在栈中优先级最低。

算法描述：依次读入字符。当读到一个操作数的时候，立刻把它放到输出中；
当读到操作符“+”、“*”、“(”中的任何一个，从栈中弹出栈元素直到发现优先级更低的元素为止，
然后该操作符进栈；当读到操作符“)”时将栈元素弹出直到遇到一个对应的“(”。

算法思想：栈代表挂起的操作符。在当前操作符要进栈之前，
那些栈中比它优先级高或相等的操作符就应该弹出完成计算。

例如，中缀表达式：a + b * c + (d * e + f) * g
转换成后缀表达式是：a b c * + d e * f + g * +。过程如下：

1 首先，符号a被读入，并送到输出。    输出为a,      栈为空

2 符号+ 被读入，+入栈                输出为a,      栈为+

3 符号b被读入，b送到输出             输出为ab      栈为+

4 符号*被读，
    栈顶+比*低，+不出栈，入栈，      输出为ab,     栈+*

5 符号c被读，c送到输出               输出为abc,     栈+*

6 符号+被读，
    栈顶*比+高，应该弹出来计算，     输出为abc*      栈+
    栈顶+和+相等，弹出来到输出       输出为abc*+     栈空
    此时栈中，没有比符号+高
    +入栈                            输出为abc*+     栈+

7 符号(被读，
    (优先级最高，不比。入栈          输出为abc*+,    栈+(

8 符号d被读，送到输出                输出为abc*+d    栈+(

9 符号*被读，
    入栈后的(优先级最低，            输出为abc*+d,   栈+(*

10 符号e被读，到输出                 输出为abc*+de   栈+(*

11 符号+被读
    栈顶*比+高，弹出                 输出为abc*+de*   栈+(
    栈顶(优先级最低，不出
    +号入栈                          输出为abc*+de*    栈+(+

12 符号f被读                         输出为abc*+de*f   栈+(+

13 符号)被读，)优先级最低
   所以栈元素弹出                    输出为abc*+de*f+  栈+
   遇到(,(会弹出但是不到输出

14 符号*被读，
    栈顶+比*第，*入栈                输出为abc*+de*f+  栈+*

15 符号g被读                         输出为abc*+de*f+g 栈+*

16 输入为空，弹出栈                  输出为abc*+de*f+g*+



